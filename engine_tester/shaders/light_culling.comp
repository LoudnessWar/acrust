#version 430 core

// Work group size (should match tile size)
layout(local_size_x = 16, local_size_y = 16) in;

// Light structure
struct Light {
    vec3 position;
    float radius;
    vec3 color;
    float intensity;
};

// Input: light data
layout(std430, binding = 0) buffer LightBuffer {
    Light lights[];
};

// Output: light grid (per-tile light count and offset)
layout(std430, binding = 1) buffer LightGrid {
    // For each tile: [offset, count]
    ivec2 grid[];
};

// Output: light indices
struct VisibleIndex {
	int index;
};

layout(std430, binding = 2) writeonly buffer VisibleLightIndicesBuffer  {
    VisibleIndex data[];
} IndicesBuffer;


// Depth texture
uniform sampler2D u_depthTexture;

uniform mat4 view;
uniform mat4 projection;

// Uniforms
uniform int u_lightCount;
uniform float u_screenWidth;
uniform float u_screenHeight;

// Shared memory for light culling within a work group
shared uint minDepthInt;
shared uint maxDepthInt;
shared uint visibleLightCount;
shared int visibleLightIndices[256]; // Increased from 64 to handle more lights
shared vec4 frustumPlanes[6];
shared mat4 viewProjection;

#define TILE_SIZE 16

// Utility function to check if a sphere intersects with the frustum
bool sphereInFrustum(vec3 center, float radius, vec4 planes[6]) {
    for (int i = 0; i < 6; i++) {
        if (dot(vec4(center, 1.0), planes[i]) + radius <= 0.0) {
            return false;
        }
    }
    return true;
}

void main() {
    // Get tile coordinates
    uvec2 tileID = gl_WorkGroupID.xy;
    uvec2 localID = gl_LocalInvocationID.xy;
    ivec2 location = ivec2(gl_GlobalInvocationID.xy);
    ivec2 tileNumber = ivec2(gl_NumWorkGroups.xy);
    uint tileIndex = tileID.y * tileNumber.x + tileID.x;
    
    // Initialize shared values
    if (gl_LocalInvocationIndex == 0) {
        minDepthInt = 0xFFFFFFFF;
        maxDepthInt = 0;
        visibleLightCount = 0;
        viewProjection = projection * view;
    }
    
    barrier();
    
    // Step 1: Find min/max depth in this tile
    vec2 uv = vec2(location) / vec2(u_screenWidth, u_screenHeight);
    float depth = texture(u_depthTexture, uv).r;
    
    // Linearize depth
    depth = (0.5 * projection[3][2]) / (depth + 0.5 * projection[2][2] - 0.5);
    
    // Convert to uint for atomic operations
    uint depthInt = floatBitsToUint(depth);
    atomicMin(minDepthInt, depthInt);
    atomicMax(maxDepthInt, depthInt);
    
    barrier();
    
    // Step 2: Calculate frustum planes (only one thread)
    if (gl_LocalInvocationIndex == 0) {
        // Convert min/max depth back to float
        float minDepth = uintBitsToFloat(minDepthInt);
        float maxDepth = uintBitsToFloat(maxDepthInt);
        
        // Calculate steps based on tile size
        vec2 negativeStep = (2.0 * vec2(tileID)) / vec2(tileNumber);
        vec2 positiveStep = (2.0 * vec2(tileID + ivec2(1, 1))) / vec2(tileNumber);
        
        // Set up frustum planes
        frustumPlanes[0] = vec4(1.0, 0.0, 0.0, 1.0 - negativeStep.x); // Left
        frustumPlanes[1] = vec4(-1.0, 0.0, 0.0, -1.0 + positiveStep.x); // Right
        frustumPlanes[2] = vec4(0.0, 1.0, 0.0, 1.0 - negativeStep.y); // Bottom
        frustumPlanes[3] = vec4(0.0, -1.0, 0.0, -1.0 + positiveStep.y); // Top
        frustumPlanes[4] = vec4(0.0, 0.0, -1.0, -minDepth); // Near
        frustumPlanes[5] = vec4(0.0, 0.0, 1.0, maxDepth); // Far
        
        // Transform the first four planes
        for (uint i = 0; i < 4; i++) {
            frustumPlanes[i] *= viewProjection;
            frustumPlanes[i] /= length(frustumPlanes[i].xyz);
        }
        
        // Transform the depth planes
        frustumPlanes[4] *= view;
        frustumPlanes[4] /= length(frustumPlanes[4].xyz);
        frustumPlanes[5] *= view;
        frustumPlanes[5] /= length(frustumPlanes[5].xyz);
    }
    
    barrier();
    
    // Step 3: Cull lights against frustum
    uint threadCount = TILE_SIZE * TILE_SIZE;
    uint passCount = (u_lightCount + threadCount - 1) / threadCount;
    
    for (uint i = 0; i < passCount; i++) {
        uint lightIndex = i * threadCount + gl_LocalInvocationIndex;
        if (lightIndex >= u_lightCount) {
            break;
        }
        
        Light light = lights[lightIndex];
        
        // Check if light intersects tile frustum
        bool visible = sphereInFrustum(light.position, light.radius, frustumPlanes);
        
        if (visible) {
            uint offset = atomicAdd(visibleLightCount, 1);
            if (offset < 256) { // Make sure we don't overflow our shared array
                visibleLightIndices[offset] = int(lightIndex);
            }
        }
    }
    
    barrier();
    
    // Step 4: Write results to global buffers
    if (gl_LocalInvocationIndex == 0) {
        // Store offset and count in the grid
        uint offset = tileIndex * 256; // Max lights per tile
        grid[tileIndex] = ivec2(offset, visibleLightCount);
        
        // Copy visible light indices to global buffer
        for (uint i = 0; i < visibleLightCount && i < 256; i++) {
            IndicesBuffer.data[offset + i].index = visibleLightIndices[i];
        }
        
        // Mark the end of the list with -1 if not full
        if (visibleLightCount < 256) {
            IndicesBuffer.data[offset + visibleLightCount].index = -1;
            //visibleLightIndices.data[offset + visibleLightCount].index = -1;
        }
    }

    if (gl_GlobalInvocationID.x == 0 && gl_GlobalInvocationID.y == 0) {
        for (int i = 0; i < 10; ++i) {
            //int idx = visibleLightIndicesBuffer.data[i].index;
            //printf("Index[%d] = %d\n", i, idx);
        }
    }

}