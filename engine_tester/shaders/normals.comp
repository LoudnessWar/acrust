#version 450 core

layout(local_size_x = 256) in;

layout(std430, binding = 0) buffer VertexBuffer {
    float vertices[];
};

layout(std430, binding = 1) readonly buffer IndexBuffer {
    int indices[];
};

uniform int vertex_count;
uniform int index_count;

//blah blah blah this used to have a normals buffer so i could like get the normals or whatever... and then I realized I didnt like need it
//it was going to be hella buggy like
//I would interlace it and rebind the vbo but then I was like do it here
//but then I was like naaah the utility of having the buffer
//but then I took it out and its lowkey chillin
void main() {
    uint id = gl_GlobalInvocationID.x;

    if (id * 3 + 2 < index_count) {
        int idx1 = indices[id * 3];
        int idx2 = indices[id * 3 + 1];
        int idx3 = indices[id * 3 + 2];

        vec3 v1 = vec3(vertices[idx1 * 6 + 0], vertices[idx1 * 6 + 1], vertices[idx1 * 6 + 2]);
        vec3 v2 = vec3(vertices[idx2 * 6 + 0], vertices[idx2 * 6 + 1], vertices[idx2 * 6 + 2]);
        vec3 v3 = vec3(vertices[idx3 * 6 + 0], vertices[idx3 * 6 + 1], vertices[idx3 * 6 + 2]);

        vec3 edge1 = v2 - v1;
        vec3 edge2 = v3 - v1;
        vec3 faceNormal = normalize(cross(edge1, edge2));

        for (int i = 0; i < 3; ++i) {
            int idx = indices[id * 3 + i];
            uint base = idx * 6 + 3;
            vertices[base + 0] += faceNormal.x;
            vertices[base + 1] += faceNormal.y;
            vertices[base + 2] += faceNormal.z;
        }
    }

    barrier();
    memoryBarrierBuffer();//ok bascially like the atomic stuff is like tweaking so I did this approach instead

    if (id < vertex_count) {
        uint base = id * 6 + 3;
        vec3 norm = vec3(vertices[base + 0], vertices[base + 1], vertices[base + 2]);
        if (length(norm) > 0.0001) {
            norm = normalize(norm);
            vertices[base + 0] = norm.x;
            vertices[base + 1] = norm.y;
            vertices[base + 2] = norm.z;
        }
    }
}
